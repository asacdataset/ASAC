题目背景
本题中合法括号串的定义如下：

() 是合法括号串。
如果 A 是合法括号串，则 (A) 是合法括号串。
如果 A，B 是合法括号串，则 AB 是合法括号串。
本题中子串与不同的子串的定义如下：

字符串 S 的子串是 S 中连续的任意个字符组成的字符串。S 的子串可用起始位置 ll 与终止位置 rr 来表示，记为 S (l, r)S(l,r)（1 \leq l \leq r \leq |S |1≤l≤r≤∣S∣，|S |∣S∣ 表示 S 的长度）。
S 的两个子串视作不同当且仅当它们在 S 中的位置不同，即 ll 不同或 rr 不同。
题目描述
一个大小为 nn 的树包含 nn 个结点和 n − 1n−1 条边，每条边连接两个结点，且任意两个结点间有且仅有一条简单路径互相可达。

小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 nn 的树，树上结点从 11 ∼ nn 编号，11 号结点为树的根。除 11 号结点外，每个结点有一个父亲结点，uu（2 \leq u \leq n2≤u≤n）号结点的父亲为 f_uf 
u
​
 （1 ≤ f_u < u1≤f 
u
​
 <u）号结点。

小 Q 发现这个树的每个结点上恰有一个括号，可能是( 或)。小 Q 定义 s_is 
i
​
  为：将根结点到 ii 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。

显然 s_is 
i
​
  是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 ii（1\leq i\leq n1≤i≤n）求出，s_is 
i
​
  中有多少个互不相同的子串是合法括号串。

这个问题难倒了小 Q，他只好向你求助。设 s_is 
i
​
  共有 k_ik 
i
​
  个不同子串是合法括号串， 你只需要告诉小 Q 所有 i \times k_ii×k 
i
​
  的异或和，即：

(1 \times k_1)\ \text{xor}\ (2 \times k_2)\ \text{xor}\ (3 \times k_3)\ \text{xor}\ \cdots\ \text{xor}\ (n \times k_n)
(1×k 
1
​
 ) xor (2×k 
2
​
 ) xor (3×k 
3
​
 ) xor ⋯ xor (n×k 
n
​
 )

其中 xorxor 是位异或运算。